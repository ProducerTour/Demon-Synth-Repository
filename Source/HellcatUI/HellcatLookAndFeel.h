#pragma once
#include <JuceHeader.h>

// Forward declare BinaryData - it's generated by juce_add_binary_data
namespace BinaryData
{
    extern const char* OrbitronBold_ttf;
    extern const int OrbitronBold_ttfSize;
    extern const char* OrbitronBlack_ttf;
    extern const int OrbitronBlack_ttfSize;
    extern const char* RajdhaniBold_ttf;
    extern const int RajdhaniBold_ttfSize;
    extern const char* RajdhaniSemiBold_ttf;
    extern const int RajdhaniSemiBold_ttfSize;
    extern const char* Sofachrome_Rg_otf;
    extern const int Sofachrome_Rg_otfSize;
    extern const char* Sofachrome_Rg_It_otf;
    extern const int Sofachrome_Rg_It_otfSize;
}

namespace HellcatColors
{
    const juce::Colour background     (0xff050608);
    const juce::Colour panelDark      (0xff111217);
    const juce::Colour panelLight     (0xff1a1d22);
    const juce::Colour hellcatRed     (0xffDF1F2F);
    const juce::Colour redDark        (0xffa01620);
    const juce::Colour redBright      (0xffff4040);
    const juce::Colour textPrimary    (0xffffffff);
    const juce::Colour textSecondary  (0xff888888);
    const juce::Colour textTertiary   (0xff666666);
}

class HellcatLookAndFeel : public juce::LookAndFeel_V4
{
public:
    HellcatLookAndFeel()
    {
        // Load custom fonts from binary resources
        if (BinaryData::OrbitronBold_ttf != nullptr)
            orbitronBold = juce::Typeface::createSystemTypefaceFor(
                BinaryData::OrbitronBold_ttf, BinaryData::OrbitronBold_ttfSize);
        if (BinaryData::OrbitronBlack_ttf != nullptr)
            orbitronBlack = juce::Typeface::createSystemTypefaceFor(
                BinaryData::OrbitronBlack_ttf, BinaryData::OrbitronBlack_ttfSize);
        if (BinaryData::RajdhaniBold_ttf != nullptr)
            rajdhaniBold = juce::Typeface::createSystemTypefaceFor(
                BinaryData::RajdhaniBold_ttf, BinaryData::RajdhaniBold_ttfSize);
        if (BinaryData::RajdhaniSemiBold_ttf != nullptr)
            rajdhaniSemiBold = juce::Typeface::createSystemTypefaceFor(
                BinaryData::RajdhaniSemiBold_ttf, BinaryData::RajdhaniSemiBold_ttfSize);
        if (BinaryData::Sofachrome_Rg_otf != nullptr)
            sofachrome = juce::Typeface::createSystemTypefaceFor(
                BinaryData::Sofachrome_Rg_otf, BinaryData::Sofachrome_Rg_otfSize);
        if (BinaryData::Sofachrome_Rg_It_otf != nullptr)
            sofachromeItalic = juce::Typeface::createSystemTypefaceFor(
                BinaryData::Sofachrome_Rg_It_otf, BinaryData::Sofachrome_Rg_It_otfSize);

        // Set default colors
        setColour(juce::ResizableWindow::backgroundColourId, HellcatColors::background);
        setColour(juce::DocumentWindow::backgroundColourId, HellcatColors::background);
        setColour(juce::ComboBox::backgroundColourId, juce::Colour(0xff0a0c0f));
        setColour(juce::ComboBox::outlineColourId, HellcatColors::panelLight);
        setColour(juce::ComboBox::textColourId, HellcatColors::textPrimary);
        setColour(juce::TextButton::buttonColourId, HellcatColors::panelLight);
        setColour(juce::TextButton::textColourOffId, HellcatColors::textTertiary);
        setColour(juce::TextButton::textColourOnId, HellcatColors::textPrimary);
        setColour(juce::Label::textColourId, HellcatColors::textPrimary);
        setColour(juce::Slider::textBoxTextColourId, HellcatColors::textPrimary);
        setColour(juce::Slider::textBoxOutlineColourId, HellcatColors::panelLight);
    }

    // Custom font accessors - Orbitron for titles/values, Rajdhani for labels/body
    // All methods return safe fallbacks if fonts failed to load
    juce::Font getOrbitronFont(float height) const
    {
        if (orbitronBold != nullptr)
            return juce::Font(orbitronBold).withHeight(height);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), height, juce::Font::bold);
    }

    juce::Font getOrbitronBlackFont(float height) const
    {
        if (orbitronBlack != nullptr)
            return juce::Font(orbitronBlack).withHeight(height);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), height, juce::Font::bold);
    }

    juce::Font getRajdhaniFont(float height) const
    {
        if (rajdhaniBold != nullptr)
            return juce::Font(rajdhaniBold).withHeight(height);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), height, juce::Font::bold);
    }

    juce::Font getRajdhaniSemiBoldFont(float height) const
    {
        if (rajdhaniSemiBold != nullptr)
            return juce::Font(rajdhaniSemiBold).withHeight(height);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), height, juce::Font::plain);
    }

    juce::Font getSofachromeFont(float height) const
    {
        if (sofachrome != nullptr)
            return juce::Font(sofachrome).withHeight(height);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), height, juce::Font::bold);
    }

    juce::Font getSofachromeItalicFont(float height) const
    {
        if (sofachromeItalic != nullptr)
            return juce::Font(sofachromeItalic).withHeight(height);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), height, juce::Font::italic);
    }

    // Override JUCE font methods to use Rajdhani as default (with fallbacks)
    juce::Font getLabelFont(juce::Label& label) override
    {
        if (rajdhaniBold != nullptr)
            return juce::Font(rajdhaniBold).withHeight(label.getFont().getHeight());
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), label.getFont().getHeight(), juce::Font::bold);
    }

    juce::Font getComboBoxFont(juce::ComboBox&) override
    {
        if (rajdhaniBold != nullptr)
            return juce::Font(rajdhaniBold).withHeight(14.0f);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), 14.0f, juce::Font::bold);
    }

    juce::Font getPopupMenuFont() override
    {
        if (rajdhaniBold != nullptr)
            return juce::Font(rajdhaniBold).withHeight(14.0f);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), 14.0f, juce::Font::bold);
    }

    juce::Font getSliderPopupFont(juce::Slider&) override
    {
        if (rajdhaniSemiBold != nullptr)
            return juce::Font(rajdhaniSemiBold).withHeight(12.0f);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), 12.0f, juce::Font::plain);
    }

    juce::Font getTextButtonFont(juce::TextButton&, int) override
    {
        if (rajdhaniBold != nullptr)
            return juce::Font(rajdhaniBold).withHeight(12.0f);
        return juce::Font(juce::Font::getDefaultSansSerifFontName(), 12.0f, juce::Font::bold);
    }

private:
    juce::Typeface::Ptr orbitronBold;
    juce::Typeface::Ptr orbitronBlack;
    juce::Typeface::Ptr rajdhaniBold;
    juce::Typeface::Ptr rajdhaniSemiBold;
    juce::Typeface::Ptr sofachrome;
    juce::Typeface::Ptr sofachromeItalic;

public:
    
    void drawRotarySlider(juce::Graphics& g, int x, int y, int width, int height,
                         float sliderPos, float rotaryStartAngle, float rotaryEndAngle,
                         juce::Slider& slider) override
    {
        auto radius = juce::jmin(width / 2, height / 2) - 4.0f;
        auto centerX = x + width * 0.5f;
        auto centerY = y + height * 0.5f;
        auto angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
        
        // Draw knob body with metallic gradient
        juce::ColourGradient knobGradient(
            HellcatColors::panelLight, centerX - radius * 0.3f, centerY - radius * 0.3f,
            HellcatColors::background, centerX + radius * 0.7f, centerY + radius * 0.7f,
            true
        );
        g.setGradientFill(knobGradient);
        g.fillEllipse(centerX - radius, centerY - radius, radius * 2.0f, radius * 2.0f);
        
        // Draw border
        g.setColour(HellcatColors::panelLight);
        g.drawEllipse(centerX - radius, centerY - radius, radius * 2.0f, radius * 2.0f, 3.0f);
        
        // Draw indicator
        juce::Path indicator;
        auto indicatorLength = radius * 0.3f;
        auto indicatorThickness = 4.0f;
        
        indicator.addRectangle(-indicatorThickness * 0.5f, -radius + 8.0f, 
                               indicatorThickness, indicatorLength);
        
        g.setColour(HellcatColors::hellcatRed);
        g.fillPath(indicator, juce::AffineTransform::rotation(angle)
                                .translated(centerX, centerY));
        
        // Add glow effect
        g.setColour(HellcatColors::hellcatRed.withAlpha(0.3f));
        g.drawEllipse(centerX - radius - 5, centerY - radius - 5, 
                     (radius + 5) * 2.0f, (radius + 5) * 2.0f, 10.0f);
    }
    
    void drawPopupMenuBackground(juce::Graphics& g, int width, int height) override
    {
        g.fillAll(HellcatColors::panelDark);
        g.setColour(HellcatColors::panelLight);
        g.drawRect(0, 0, width, height);
    }

    void drawPopupMenuItem(juce::Graphics& g, const juce::Rectangle<int>& area,
                          bool isSeparator, bool isActive, bool isHighlighted, bool isTicked, bool hasSubMenu,
                          const juce::String& text, const juce::String& shortcutKeyText,
                          const juce::Drawable* icon, const juce::Colour* textColour) override
    {
        if (isSeparator)
        {
            auto r = area.reduced(5, 0);
            r.removeFromTop(r.getHeight() / 2 - 1);
            g.setColour(HellcatColors::panelLight);
            g.fillRect(r.removeFromTop(1));
            return;
        }

        auto textArea = area.reduced(10, 0);

        if (isHighlighted && isActive)
        {
            g.setColour(HellcatColors::hellcatRed.withAlpha(0.3f));
            g.fillRect(area);
        }

        g.setColour(isActive ? (isHighlighted ? HellcatColors::textPrimary : HellcatColors::textSecondary)
                             : HellcatColors::textTertiary);
        g.setFont(getPopupMenuFont());
        g.drawText(text, textArea, juce::Justification::centredLeft);

        if (isTicked)
        {
            g.setColour(HellcatColors::hellcatRed);
            auto tickArea = juce::Rectangle<int>(area.getRight() - area.getHeight(), area.getY(), area.getHeight(), area.getHeight()).reduced(8);
            g.fillEllipse(tickArea.toFloat());
        }
    }

    void drawPopupMenuSectionHeader(juce::Graphics& g, const juce::Rectangle<int>& area, const juce::String& sectionName) override
    {
        g.setColour(HellcatColors::hellcatRed);
        g.setFont(getOrbitronFont(11.0f));
        g.drawText(sectionName.toUpperCase(), area.reduced(10, 0), juce::Justification::centredLeft);

        g.setColour(HellcatColors::hellcatRed.withAlpha(0.3f));
        g.fillRect(area.getX(), area.getBottom() - 1, area.getWidth(), 1);
    }

    void drawTabButton(juce::TabBarButton& button, juce::Graphics& g, bool isMouseOver, bool isMouseDown) override
    {
        // Use getLocalBounds() instead of getActiveArea() - more reliable
        auto area = button.getLocalBounds();
        auto isActive = button.getToggleState();

        // Background - ALL tabs get a visible background
        if (isActive)
        {
            // Active tab - red tinted background
            g.setColour(HellcatColors::hellcatRed.withAlpha(0.15f));
            g.fillRect(area);
        }
        else
        {
            // Inactive tabs - visible grey background
            g.setColour(juce::Colour(0xff252830));
            g.fillRect(area);

            if (isMouseOver)
            {
                g.setColour(HellcatColors::hellcatRed.withAlpha(0.1f));
                g.fillRect(area);
            }
        }

        // Border around each tab for definition
        g.setColour(HellcatColors::panelLight);
        g.drawRect(area, 1);

        // Text - Orbitron font, high contrast colors
        g.setColour(isActive ? juce::Colours::white : juce::Colour(0xffcccccc));
        g.setFont(getOrbitronFont(11.0f));
        g.drawText(button.getButtonText(), area, juce::Justification::centred);

        // Active indicator line - glowing red at bottom
        if (isActive)
        {
            g.setColour(HellcatColors::hellcatRed);
            g.fillRect(area.getX(), area.getBottom() - 3, area.getWidth(), 3);
        }
    }
    
    void drawComboBox(juce::Graphics& g, int width, int height, bool isButtonDown,
                     int buttonX, int buttonY, int buttonW, int buttonH,
                     juce::ComboBox& box) override
    {
        auto cornerSize = 4.0f;
        juce::Rectangle<int> boxBounds(0, 0, width, height);
        
        // Background gradient
        juce::ColourGradient bgGradient(
            juce::Colour(0xff0f1114), 0, 0,
            juce::Colour(0xff0a0c0f), 0, height,
            false
        );
        g.setGradientFill(bgGradient);
        g.fillRoundedRectangle(boxBounds.toFloat(), cornerSize);
        
        // Border
        g.setColour(box.hasKeyboardFocus(true) ? HellcatColors::hellcatRed : HellcatColors::panelLight);
        g.drawRoundedRectangle(boxBounds.toFloat(), cornerSize, 1.0f);
        
        // Arrow
        juce::Path arrow;
        arrow.addTriangle(buttonX + buttonW * 0.3f, buttonY + buttonH * 0.4f,
                         buttonX + buttonW * 0.7f, buttonY + buttonH * 0.4f,
                         buttonX + buttonW * 0.5f, buttonY + buttonH * 0.7f);
        g.setColour(HellcatColors::hellcatRed);
        g.fillPath(arrow);
    }
    
    void drawButtonBackground(juce::Graphics& g, juce::Button& button, const juce::Colour& backgroundColour,
                             bool shouldDrawButtonAsHighlighted, bool shouldDrawButtonAsDown) override
    {
        auto bounds = button.getLocalBounds().toFloat();
        auto cornerSize = 6.0f;

        if (button.getToggleState())
        {
            juce::ColourGradient activeGradient(
                HellcatColors::hellcatRed, bounds.getX(), bounds.getY(),
                HellcatColors::redDark, bounds.getX(), bounds.getBottom(),
                false
            );
            g.setGradientFill(activeGradient);
            g.fillRoundedRectangle(bounds, cornerSize);

            // Inner highlight
            g.setColour(juce::Colours::white.withAlpha(0.2f));
            g.drawRoundedRectangle(bounds.reduced(1), cornerSize, 1.0f);
        }
        else
        {
            juce::ColourGradient inactiveGradient(
                juce::Colour(0xff0f1114), bounds.getX(), bounds.getY(),
                juce::Colour(0xff0a0c0f), bounds.getX(), bounds.getBottom(),
                false
            );
            g.setGradientFill(inactiveGradient);
            g.fillRoundedRectangle(bounds, cornerSize);
        }

        // Border
        g.setColour(button.getToggleState() ? HellcatColors::hellcatRed : HellcatColors::panelLight);
        g.drawRoundedRectangle(bounds, cornerSize, 1.0f);

        if (shouldDrawButtonAsHighlighted && !button.getToggleState())
        {
            g.setColour(HellcatColors::hellcatRed.withAlpha(0.1f));
            g.fillRoundedRectangle(bounds, cornerSize);
        }
    }

    void drawTabAreaBehindFrontButton(juce::TabbedButtonBar& bar, juce::Graphics& g, int w, int h) override
    {
        // Draw dark background behind tabs
        g.setColour(HellcatColors::background);
        g.fillRect(0, 0, w, h);

        // Bottom border line
        g.setColour(HellcatColors::panelLight);
        g.fillRect(0, h - 1, w, 1);
    }

    void drawTabbedButtonBarBackground(juce::TabbedButtonBar& bar, juce::Graphics& g) override
    {
        g.setColour(HellcatColors::background);
        g.fillAll();
    }

    int getTabButtonBestWidth(juce::TabBarButton& button, int tabDepth) override
    {
        // Calculate width based on text
        auto font = getOrbitronFont(11.0f);
        int textWidth = font.getStringWidth(button.getButtonText());
        return textWidth + 30; // Text width plus padding
    }

    int getTabButtonOverlap(int tabDepth) override
    {
        return 0; // No overlap between tabs
    }

    // Disable the "extra tabs" overflow button - this forces all tabs to be visible
    juce::Button* createTabBarExtrasButton() override
    {
        return nullptr;
    }

    int getDefaultScrollbarWidth() override { return 10; }

    void drawScrollbar(juce::Graphics& g, juce::ScrollBar& scrollbar, int x, int y, int width, int height,
                      bool isScrollbarVertical, int thumbStartPosition, int thumbSize,
                      bool isMouseOver, bool isMouseDown) override
    {
        // Track
        g.setColour(HellcatColors::background);
        g.fillRect(x, y, width, height);

        // Thumb
        juce::Rectangle<int> thumbBounds;
        if (isScrollbarVertical)
            thumbBounds = juce::Rectangle<int>(x + 2, thumbStartPosition, width - 4, thumbSize);
        else
            thumbBounds = juce::Rectangle<int>(thumbStartPosition, y + 2, thumbSize, height - 4);

        g.setColour(isMouseDown ? HellcatColors::hellcatRed :
                   (isMouseOver ? HellcatColors::panelLight.brighter(0.2f) : HellcatColors::panelLight));
        g.fillRoundedRectangle(thumbBounds.toFloat(), 4.0f);
    }

    void drawTextEditorOutline(juce::Graphics& g, int width, int height, juce::TextEditor& editor) override
    {
        if (editor.isEnabled())
        {
            g.setColour(editor.hasKeyboardFocus(true) ? HellcatColors::hellcatRed : HellcatColors::panelLight);
            g.drawRoundedRectangle(0.5f, 0.5f, width - 1.0f, height - 1.0f, 4.0f, 1.0f);
        }
    }

    void fillTextEditorBackground(juce::Graphics& g, int width, int height, juce::TextEditor& editor) override
    {
        juce::ColourGradient bgGradient(
            juce::Colour(0xff0f1114), 0, 0,
            juce::Colour(0xff0a0c0f), 0, height,
            false
        );
        g.setGradientFill(bgGradient);
        g.fillRoundedRectangle(0, 0, width, height, 4.0f);
    }
};
